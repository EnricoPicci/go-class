# Dealock scenarios generated by mutex

Here there are 2 examples of deadlocks.

## Deadlock detected by the Go runtime

In this example the deadlock is detected by the Go runtime since, when the deadlock occurs, all the goroutines are mutually blocked on the same mutexes (criss cross blocking situation).

Since there is no goroutine in a runnable state that can eventually unlock at least one of the mutexes, then the Go runtime is able to detect the deadlock situation.

## Deadlock that can not be detected by the Go runtime

This is the same example as the one above, with the only difference that there is also a goroutine which performs some different work and is not locked.

In this case the Go runtime can not detect the deadlock situation since it can not understand that the goroutine in a runnable state will never unlock at least one of the locked mutexes.

These are the worst situations, since we may end up being not aware of the deadlock, but unfortunately are also the mst frequent in real world applications.

### build deadlock detected by the Go runtime

From the GO-CLASS project folder run the command
`go build -o ./bin/deadlocks-mutex-detected ./src/synchronization/deadlocks-mutex/deadlocks-mutex-detected`

### run deadlock detected by the Go runtime

From the GO-CLASS project folder run the command
`./bin/deadlocks-mutex-detected`

### build deadlock NOT detected by the Go runtime

From the GO-CLASS project folder run the command
`go build -o ./bin/deadlocks-mutex-undetected ./src/synchronization/deadlocks-mutex/deadlocks-mutex-undetected`

### run deadlock NOT detected by the Go runtime

From the GO-CLASS project folder run the command
`./bin/deadlocks-mutex-undetected`
